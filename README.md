# **Repository Docifier**

### AI-Powered Repository Documentation Generator

[![TypeScript](https://img.shields.io/badge/TypeScript-3178C6?style=for-the-badge&logo=typescript&logoColor=white)](https://www.typescriptlang.org/)
[![React](https://img.shields.io/badge/React-61DAFB?style=for-the-badge&logo=react&logoColor=black)](https://react.dev/)
[![npm](https://img.shields.io/badge/npm-CB3837?style=for-the-badge&logo=npm&logoColor=white)](https://www.npmjs.com/)

Built with the tools and technologies:

[![Next.js](https://img.shields.io/badge/Next.js-000000?style=for-the-badge&logo=nextdotjs&logoColor=white)](https://nextjs.org/)
[![Tailwind CSS](https://img.shields.io/badge/Tailwind_CSS-38B2AC?style=for-the-badge&logo=tailwind-css&logoColor=white)](https://tailwindcss.com/)
[![Zustand](https://img.shields.io/badge/Zustand-3690c0?style=for-the-badge&logo=javascript&logoColor=white)](https://github.com/pmndrs/zustand)
[![Radix UI](https://img.shields.io/badge/Radix_UI-161E26?style=for-the-badge&logo=data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cGF0aCBkPSJNMTIgMTQuMTYyMUMxMiAxNC4xNjIxIDguNzYxNDQgMTIuMjcwNiA3LjA0ODQ0IDExLjMyMDVDNS4zMzU0NCAxMC4zNzA0IDQuMzQzMTIgOS4wNzgxMiA0LjM0MzEyIDguMzk4MDJDNy42NDY2MiA4LjM5ODAyIDEyIDYuOTYwMTIgMTIgNi45NjAxMkMxMiA2Ljk2MDEyIDE2LjMzMzQgOC4zOTgwMiAxOS42NTY5IDguMzk4MDJDMTkuNjU2OSA5LjA3ODEyIDE4LjY2NDYgMTAuMzcwNCAxNi45NTE2IDExLjMyMDVDMTUuMjM4NiAxMi4yNzA2IDEyIDE0LjE2MjEgMTIgMTQuMTYyMVoiIGZpbGw9IiM3RkZBRDAiLz4KICA8cGF0aCBkPSJNMTIgMTcuMDM3OUMxMiAxNy4wMzc5IDguNzYxNDQgMTUuMTQ2NCA3LjA0ODQ0IDE0LjAzNTVDNS4zMzU0NCAxMy4xMjQ2IDQuMzQzMTIgMTEuODEyMyA0LjM0MzEyIDEwLjk1MjJDNy42NDY2MiAxMC45NTIyIDEyIDEyLjM5MDEgMTIgMTIuMzkwMUMxMiAxMi4zOTAxIDE2LjMzMzQgMTAuOTUyMiAxOS42NTY5IDEwLjk1MjJDMTkuNjU2OSAxMS44MTIzIDE4LjY2NDYgMTMuMTI0NiAxNi45NTE2IDE0LjAzNTVDMTUuMjM4NiAxNS4xNDY0IDEyIDE3LjAzNzkgMTIgMTcuMDM3OVoiIGZpbGw9IiM3RkZBRDAiLz4KPC9zdmc+)](https://www.radix-ui.com/)
[![Monaco Editor](https://img.shields.io/badge/Monaco_Editor-1F2937?style=for-the-badge&logo=visual-studio-code&logoColor=white)](https://microsoft.github.io/monaco-editor/)

## Table of Contents

- [Overview](#overview)
- [Getting Started](#getting-started)
  - [Prerequisites](#prerequisites)
  - [Installation](#installation)
  - [Usage](#usage)
- [Testing](#testing)
- [Key Features](#key-features)
- [Folder Structure](#folder-structure)
- [Contributing](#contributing)
- [License](#license)

## Overview

Repository Docifier, also known as CodeVibe, is an innovative AI-powered platform designed to enhance the coding experience for users of all skill levels. It provides a comprehensive suite of tools and features, including a Monaco-powered code editor, AI-assisted explanations, content recommendations, and a collaborative discussion forum. The platform leverages modern technologies such as React, Next.js, TypeScript, and Zustand to deliver a seamless and engaging user experience.

### Why Repository Docifier?

*   **Enhanced Learning:** AI-powered explanations and content recommendations help users understand complex coding concepts more effectively.
*   **Collaborative Environment:** The discussion forum fosters a community where users can share knowledge and learn from each other.
*   **Streamlined Workflow:** The integrated code editor and test case management tools simplify the coding process.
*   **Personalized Experience:** User-specific progress tracking and activity data provide a tailored learning journey.

## Key Features

*   üßë‚Äçüíª **Monaco Code Editor:** A powerful and customizable code editor with syntax highlighting and autocompletion.
*   ü§ñ **AI-Powered Explanations:** Get instant explanations of code snippets from an AI assistant.
*   üìö **Content Recommendations:** Discover relevant learning resources based on your understanding level and search queries.
*   üí¨ **Discussion Forum:** Engage in discussions, share knowledge, and ask questions with other users.
*   üìä **Progress Tracking:** Monitor your coding progress with detailed statistics and activity feeds.
*   üîê **User Authentication:** Secure user authentication and authorization to protect your data.
*   üé® **Styled UI Components:** Utilizing Radix UI and Tailwind CSS to create a visually appealing and consistent user interface.
*   ‚ú® **Animations and Effects:** Engaging animations and effects using Lottie and Framer Motion.

## Getting Started

Follow these instructions to get a copy of the project up and running on your local machine for development and testing purposes.

### Prerequisites

Before you begin, ensure you have the following installed:

*   **Node.js:** v18 or higher ([https://nodejs.org/](https://nodejs.org/))
*   **npm:** v8 or higher (comes with Node.js)
*   **Git:**  ([https://git-scm.com/](https://git-scm.com/))

### Installation

1.  **Clone the repository:**

    ```bash
    git clone https://github.com/your-username/repository-docifier.git
    ```

2.  **Navigate to the project directory:**

    ```bash
    cd repository-docifier
    ```

3.  **Install dependencies:**

    ```bash
    npm install
    ```

### Usage

To start the development server:

```bash
npm run dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Testing

To run the tests:

```bash
npm test
```

## Key Features

- **Code Editor**: The core of the application, providing a Monaco-based environment for writing and testing code.
- **AI Assistance**: Integrated AI to help users understand code and learn more effectively.
- **User Profiles**: Personalized dashboards to track progress and engage with the community.
- **Discussion Forums**: Spaces for users to collaborate, share knowledge, and get help.
- **Adaptive Learning**: Recommendations and content tailored to the user's level and needs.

## Folder Structure

```
devbh04-codevibe-8004e26/
‚îú‚îÄ‚îÄ app/                 # Next.js application routes and pages
‚îÇ   ‚îú‚îÄ‚îÄ (root)/         # Root route group
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ code-editor/  # Code editor page
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ discussion/   # Discussion page
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ progress/     # Progress page
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ profile/      # User profile page
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx    # Root layout component
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx      # Homepage
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx        # Main layout component
‚îú‚îÄ‚îÄ components/        # Reusable React components
‚îÇ   ‚îú‚îÄ‚îÄ shared/         # Shared components (e.g., AppBar, Footer)
‚îÇ   ‚îú‚îÄ‚îÄ ui/             # UI components (e.g., Button, Dialog)
‚îú‚îÄ‚îÄ lib/                 # Utility functions and configuration
‚îú‚îÄ‚îÄ store/              # Zustand stores for state management
‚îú‚îÄ‚îÄ public/              # Static assets
‚îú‚îÄ‚îÄ styles/             # Global CSS styles
‚îú‚îÄ‚îÄ next.config.js      # Next.js configuration
‚îú‚îÄ‚îÄ package.json        # Project dependencies and scripts
‚îú‚îÄ‚îÄ README.md           # Project documentation
‚îú‚îÄ‚îÄ tsconfig.json       # TypeScript configuration
```

## Contributing

Contributions are welcome! Please follow these steps:

1.  Fork the repository.
2.  Create a new branch for your feature or bug fix.
3.  Make your changes and commit them with descriptive messages.
4.  Push your changes to your fork.
5.  Submit a pull request.

## License

This project is licensed under the [MIT License](LICENSE).

# Tutorial: Understanding the Repository

---


Welcome to this hands-on tutorial!

Over the next 7 chapters, we will take a deep dive into this codebase. This guide is designed for developers who want to quickly get up to speed with the project's architecture, key features, and development workflows.

We will start with the basics in 'Setting Up Your Next.js Project and Understanding Project Structure' and progressively build up to more advanced topics, culminating in 'Building a Discussion Feature'. By the end, you'll have a solid understanding of how the project works and how you can contribute to it.

Let's get started!


---

# Table of Contents
- [Chapter 1: Setting Up Your Next.js Project and Understanding Project Structure](#chapter-1-setting-up-your-next.js-project-and-understanding-project-structure)
- [Chapter 2: Mastering Next.js File-Based Routing](#chapter-2-mastering-next.js-file-based-routing)
- [Chapter 3: Integrating a UI Library for Rapid Development](#chapter-3-integrating-a-ui-library-for-rapid-development)
- [Chapter 4: Building Reusable UI Components](#chapter-4-building-reusable-ui-components)
- [Chapter 5: Implementing Centralized State Management with Zustand](#chapter-5-implementing-centralized-state-management-with-zustand)
- [Chapter 6: Creating a Dynamic Code Editor Feature](#chapter-6-creating-a-dynamic-code-editor-feature)
- [Chapter 7: Building a Discussion Feature](#chapter-7-building-a-discussion-feature)

---

<a name="chapter-1-setting-up-your-next.js-project-and-understanding-project-structure"></a>

---

```markdown
## Chapter 1: Setting Up Your Next.js Project and Understanding Project Structure

Welcome to the first chapter of this Next.js tutorial! In this chapter, we'll guide you through setting up a brand new Next.js project and introduce you to the crucial configuration files that power your application. Our objective is to get you comfortable with the initial setup and understand the purpose of key configuration files like `next.config.js` and `tsconfig.json`.

### Creating a New Next.js Project

Before diving into the configuration files, let's quickly recap how to create a new Next.js project. Open your terminal and run the following command:

```bash
npx create-next-app@latest my-nextjs-app
```

Replace `my-nextjs-app` with your desired project name. The command will prompt you with a series of questions regarding your preferred configuration. Choose the options that best suit your needs. For this tutorial, we'll assume you've selected TypeScript, ESLint, Tailwind CSS, `src/` directory, and import aliases (@/).

Once the installation is complete, navigate to your project directory:

```bash
cd my-nextjs-app
```

Now, let's explore the project structure and the important configuration files.

### Understanding `next.config.js`

The `next.config.js` file (or `next.config.ts` if you chose TypeScript) is the heart of your Next.js application's configuration. It allows you to customize various aspects of the framework, such as:

*   **Environment Variables:** Define variables accessible during the build process or runtime.
*   **Image Optimization:** Configure image optimization settings.
*   **Rewrites and Redirects:** Define URL rewrites and redirects.
*   **Webpack Configuration:** Customize the underlying Webpack configuration (advanced).

Let's take a look at a basic `next.config.ts` file:

```typescript
// FILE: next.config.ts

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
```

As you can see, it's a simple JavaScript or TypeScript file that exports a `nextConfig` object.  The `NextConfig` type from the `next` package provides type safety for your configuration options.  Inside this object, you can add your desired configurations.

**Practical Example: Adding a simple environment variable**

Let's add a simple environment variable to our `next.config.js` file:

```typescript
// FILE: next.config.ts

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  env: {
    MY_APP_NAME: "My Awesome Next.js App",
  },
};

export default nextConfig;
```

Now, you can access this environment variable in your components using `process.env.MY_APP_NAME`.

### Understanding `tsconfig.json`

The `tsconfig.json` file is the configuration file for the TypeScript compiler. It specifies how TypeScript code should be compiled into JavaScript.  Next.js uses this file to understand your TypeScript code and ensure type safety.

Let's examine the typical contents of a `tsconfig.json` file generated by `create-next-app`:

```json
// FILE: tsconfig.json

{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

Let's break down some of the key options:

*   **`compilerOptions`**: This section contains the core compiler settings.
    *   **`target`**: Specifies the ECMAScript target version (e.g., ES2017).
    *   **`lib`**: Specifies the libraries to include during compilation (e.g., `dom`, `esnext`).
    *   **`allowJs`**: Allows importing JavaScript files into TypeScript code.
    *   **`strict`**: Enables strict type checking options.  Setting this to `true` is generally recommended for more robust code.
    *   **`noEmit`**: Prevents the compiler from emitting JavaScript files (Next.js handles the compilation process).
    *   **`esModuleInterop`**: Enables interoperability between CommonJS and ES modules.
    *   **`module`**: Specifies the module system to use (e.g., `esnext`).
    *   **`moduleResolution`**:  Specifies how modules are resolved. `bundler` is a modern approach designed for bundlers like Webpack (used by Next.js).
    *   **`jsx`**: Specifies how JSX code should be transformed (e.g., `preserve`).
    *   **`paths`**: Allows you to define path aliases (e.g., `@/*` maps to the project root).
*   **`include`**: Specifies the files to include in the compilation process.
*   **`exclude`**: Specifies the files to exclude from the compilation process (e.g., `node_modules`).

**Practical Example: Modifying Path Aliases**

Let's say you want to change the `@` alias to point to the `components` directory instead of the root. You would modify the `paths` section of your `tsconfig.json` like this:

```json
    "paths": {
      "@components/*": ["./components/*"]
    }
```

Now, you can import components using `@components/MyComponent`.  Remember to restart your Next.js development server after making changes to `tsconfig.json`.

### Summary

In this chapter, you learned how to set up a new Next.js project and explored the key configuration files: `next.config.js` and `tsconfig.json`. You now understand how to customize your Next.js application's behavior and configure the TypeScript compiler.

### Next Steps

In the next chapter, we'll dive into creating your first Next.js page and explore the fundamentals of routing. Get ready to build your first user interface!
```

---

<a name="chapter-2-mastering-next.js-file-based-routing"></a>

---

```markdown
## Mastering Next.js File-Based Routing

**Introduction:**

Welcome to Chapter 2 of the CodeVibe tutorial! In this chapter, we'll dive into the heart of Next.js routing: the file-based routing system. This powerful feature simplifies the process of creating routes in your application by leveraging the directory structure of your `app` directory. Our objective is to equip you with the knowledge and skills to implement different routing strategies using this system, allowing you to build both static and dynamic routes with ease.

**Next.js Routing: The File-Based Approach**

Next.js uses a file-based routing system built on the `app` directory.  This means that the structure of your `app` directory directly mirrors the routes of your application. Each folder inside `app` represents a route segment.  To define a route, you simply create a `page.tsx` (or `page.jsx`) file within the corresponding folder.

For example:

*   `app/page.tsx` corresponds to the root route `/`
*   `app/about/page.tsx` corresponds to the `/about` route
*   `app/blog/page.tsx` corresponds to the `/blog` route

**Creating Static Routes**

Static routes are the simplest to create. They correspond to a fixed URL path.  As mentioned above, you just create a folder structure under the `app` directory and add a `page.tsx` file in the final directory to serve content.

**Code Walkthrough: `app/layout.tsx`**

Let's take a look at the `app/layout.tsx` file. This file defines the root layout for your application.  It's a special file that wraps all of your pages, providing a consistent UI and structure.

```typescript
import type { Metadata } from "next";
import { Work_Sans } from "next/font/google";
import "./globals.css";

const geistSans = Work_Sans({
  weight: '400',
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "CodeVibe",
  description: "CodeVibe- Leetcode Killer",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.className} h-screen text-white bg-black max-w-full`}
      >
        {children}
      </body>
    </html>
  );
}
```

*   **`import type { Metadata } from "next";`**: Imports the `Metadata` type, which allows you to define metadata for your pages (title, description, etc.).
*   **`import { Work_Sans } from "next/font/google";`**: Imports the Work Sans font from Google Fonts.  This demonstrates how to integrate custom fonts.
*   **`./globals.css`**:  Imports global CSS styles.
*   **`export const metadata: Metadata = { ... };`**: Defines the metadata for all pages in your application.  The `title` and `description` are important for SEO.
*   **`export default function RootLayout({ children, }: Readonly<{ children: React.ReactNode; }>) { ... }`**:  This is the root layout component. It receives a `children` prop, which represents the content of the individual pages. It wraps the `children` within the `<html>` and `<body>` tags, applying global styles and structure.  The `geistSans.className` applies the Work Sans font to the entire application.

**Creating Dynamic Routes**

Dynamic routes allow you to create routes with dynamic segments, often used for things like blog posts or product pages.  In Next.js, you create a dynamic route by wrapping a folder name in square brackets, like `[slug]`. This creates a dynamic route parameter called `slug`.

For example, to create a route for blog posts where each post has a unique slug, you would create a folder structure like this: `app/blog/[slug]/page.tsx`.

Inside `page.tsx`, you can access the `slug` parameter using the `useParams` hook.

**Practical Example: Creating a Blog Post Route**

1.  **Create the directory structure:** Create the folders `app/blog/[slug]`.
2.  **Create `app/blog/[slug]/page.tsx`:**

```typescript
import { useParams } from 'next/navigation';

export default function BlogPost() {
  const params = useParams();
  const { slug } = params;

  return (
    <div>
      <h1>Blog Post: {slug}</h1>
      {/* Fetch and display the blog post content based on the slug */}
    </div>
  );
}
```

In this example, `useParams` retrieves the route parameters. We then extract the `slug` from the parameters object.  You would then use this `slug` to fetch the corresponding blog post data from your database or API and display it. If you navigate to `/blog/my-first-post`, the page will display "Blog Post: my-first-post".

**Code Walkthrough: `next.config.ts`**

The `next.config.ts` file allows you to configure various aspects of your Next.js application, including routing configurations. While it doesn't directly define routes, it can be used to configure behaviors related to routing, such as redirects, rewrites, and custom headers.

```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
```

Currently, the `nextConfig` object is empty, but you can add configurations here as needed. For example, to add a redirect:

```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  async redirects() {
    return [
      {
        source: '/old-blog/:slug',
        destination: '/blog/:slug',
        permanent: true,
      },
    ]
  },
};

export default nextConfig;
```

This configuration would redirect any requests to `/old-blog/:slug` to `/blog/:slug` permanently (308 redirect).

**Summary**

In this chapter, we explored the fundamentals of Next.js file-based routing. You learned how to create static routes by creating folders and `page.tsx` files. You also learned how to create dynamic routes using square brackets in folder names and accessing parameters with the `useParams` hook.  Finally, we reviewed the `app/layout.tsx` and `next.config.ts` files and their role in defining the application layout and configuring routing.

**Next Steps**

In the next chapter, we will delve into more advanced routing techniques, including route groups and parallel routes, to build more complex and organized applications.
```

---

<a name="chapter-3-integrating-a-ui-library-for-rapid-development"></a>

---

```markdown
## Chapter 3: Integrating a UI Library for Rapid Development

In this chapter, we'll explore how to significantly speed up your UI development workflow by integrating a UI library. We'll be using `shadcn/ui`, a collection of reusable components that are easy to customize and integrate into your projects. Our objective is to equip you with the knowledge and skills to leverage pre-built components effectively, allowing you to focus on application logic rather than writing UI elements from scratch.

### Understanding UI Library Integration

UI libraries provide pre-designed and pre-built components like buttons, forms, dialogs, and more. These components are styled and often include built-in functionality, saving you considerable time and effort. `shadcn/ui` takes a unique approach: instead of being a traditional component library you install, it provides you with the *source code* of the components. This offers unparalleled customization and control. You can adapt the components to perfectly match your design and application needs.

### Setting up `shadcn/ui`

While a full setup guide is beyond the scope of this tutorial, let's assume you've already initialized your project and installed `shadcn/ui`. This typically involves running a command-line tool provided by `shadcn/ui` to add components to your project. This tool modifies your `components.json` to keep track of installed components.

Here's an example of a `components.json` file:

```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
```

This file configures `shadcn/ui` with your project's styling preferences (like the `style` and `baseColor`), the location of your Tailwind CSS file (`app/globals.css`), and important aliases for easier importing of components and utility functions. The `aliases` section maps short names like `@/components` to the actual directory paths in your project.

### Examining Key Components: `Button` and `Dialog`

Let's take a look at two essential components provided by `shadcn/ui`: the `Button` and the `Dialog`.

#### The `Button` Component

The `Button` component is a highly customizable building block for creating interactive buttons. Here's the code:

```tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-[color,box-shadow] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40",
        outline:
          "border border-input bg-background shadow-xs hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
```

This component uses `class-variance-authority` (cva) to manage different styles based on the `variant` and `size` props.  The `cn` function is a utility function (likely from `clsx` or `tailwind-merge`) that helps combine Tailwind CSS classes conditionally.  The `asChild` prop allows the `Button` to render any valid HTML element, which is useful for integrating with other components.

You can use it like this:

```tsx
import { Button } from "@/components/ui/button"

function MyComponent() {
  return (
    <div>
      <Button>Click me</Button>
      <Button variant="secondary">Secondary Button</Button>
      <Button variant="destructive">Delete</Button>
    </div>
  );
}
```

#### The `Dialog` Component

The `Dialog` component provides a modal window for displaying important information or prompting user input.

```tsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
```

The `Dialog` component leverages Radix UI primitives for accessibility and functionality. It consists of several sub-components: `Dialog`, `DialogTrigger`, `DialogContent`, `DialogOverlay`, `DialogTitle`, `DialogDescription`, `DialogFooter`, and `DialogClose`.  Each sub-component plays a specific role in creating the dialog's structure and behavior.  The `cn` function is used extensively to apply Tailwind CSS classes for styling and responsiveness.

Here's how you might use it:

```tsx
import { Button } from "@/components/ui/button"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"

function MyComponent() {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button>Open Dialog</Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Confirm Deletion</DialogTitle>
          <DialogDescription>
            Are you sure you want to delete this item? This action cannot be undone.
          </DialogDescription>
        </DialogHeader>
      </DialogContent>
    </Dialog>
  );
}
```

### Practical Example: Creating a Simple Form with a Dialog

Let's combine the `Button` and `Dialog` components to create a simple form within a dialog:

```tsx
import { Button } from "@/components/ui/button"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogFooter,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input";

function MyComponent() {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button>Add New Item</Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Add New Item</DialogTitle>
          <DialogDescription>
            Enter the details for the new item.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <div className="grid grid-cols-4 items-center gap-4">
            <label htmlFor="name" className="text-right">
              Name
            </label>
            <Input id="name" placeholder="Item Name" className="col-span-3" />
          </div>
          <div className="grid grid-cols-4 items-center gap-4">
            <label htmlFor="description" className="text-right">
              Description
            </label>
            <Input id="description" placeholder="Item Description" className="col-span-3" />
          </div>
        </div>
        <DialogFooter>
          <Button type="submit">Save</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

This example demonstrates how to use the `Dialog` to encapsulate a form, using the `Button` as a trigger.  We've also included a basic `Input` component (assuming you have one installed from `shadcn/ui` or another library) to collect user input. Remember to install the `Input` component if you haven't already.

### Summary

In this chapter, you learned how to integrate a UI library like `shadcn/ui` into your project to accelerate UI development. You explored the `Button` and `Dialog` components, understanding their structure, customization options, and usage. By leveraging pre-built components, you can focus on building application logic and creating a consistent user experience.

### Next Steps

In the next chapter, we will delve into state management and explore how to efficiently manage data and user interactions within your application.
```

---

<a name="chapter-4-building-reusable-ui-components"></a>

---

```markdown
## Chapter 4: Building Reusable UI Components

**Objective:** Create reusable UI components like buttons, inputs, and layouts for a consistent application design.

In this chapter, we'll explore the importance of reusable UI components in modern web development. Reusability not only saves time and effort but also ensures a consistent user experience throughout your application. We'll dive into creating components like buttons, inputs, and even layout elements, focusing on how to make them adaptable and maintainable.

### Shared UI Components

Shared UI components are self-contained, independent pieces of the user interface that can be used in multiple places within your application. Think of them as building blocks. Instead of writing the same code for a button multiple times, you create a single "Button" component and reuse it wherever you need a button.

**Benefits of Using Shared UI Components:**

*   **Consistency:** Ensures a uniform look and feel across the application.
*   **Maintainability:** Changes to a component are reflected everywhere it's used.
*   **Reusability:** Reduces code duplication and development time.
*   **Testability:** Easier to test individual components in isolation.

Let's examine some examples from our project's codebase.

#### AppBar Component

The `AppBar` component, located in `components/shared/appbar.tsx`, provides the navigation bar at the top of our application.  Here's the code:

```typescript jsx
// AppBar.js
'use client'
import useUserStore from '@/store/userStore';
import Link from 'next/link'
import React, { useEffect } from 'react'


const AppBAr = () => {
  const { user, logout, initialize } = useUserStore();
  
  useEffect(() => {
    initialize();
  }, [initialize]);
  
  return (
    <div className='p-4 px-10 bg-slate-900 flex justify-between items-center'>
      <div className='flex items-center space-x-6'>
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="h-8 w-8 text-purple-500">
          <path strokeLinecap="round" strokeLinejoin="round" d="M17.25 6.75 22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3-4.5 16.5" />
        </svg>
        <Link href={'/'} className='text-2xl font-extrabold'>CodeVibe</Link>
        <Link href={'/contest'} className='text-white'>Contest</Link>
        <Link href={'/discussion'} className='text-white'>Discussion</Link>
        <Link href={'/progress'} className='text-white'>Progress</Link>
      </div>

      {user ?
            <div className='flex items-center space-x-6'>
              <button onClick={logout} className='text-white bg-purple-500 p-2 rounded-lg'>Logout</button>
              <Link href={"/profile"} className='text-white p-2 rounded-full'>Hello!! {user.name}</Link>
            </div>
            :
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="h-10 w-10">
              <path strokeLinecap="round" strokeLinejoin="round" d="M17.982 18.725A7.488 7.488 0 0 0 12 15.75a7.488 7.488 0 0 0-5.982 2.975m11.963 0a9 9 0 1 0-11.963 0m11.963 0A8.966 8.966 0 0 1 12 21a8.966 8.966 0 0 1-5.982-2.275M15 9.75a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
            </svg>
        }
    </div>
  )
}

export default AppBAr
```

*   **`import` statements:** We import necessary modules like `Link` from `next/link` for navigation and `useUserStore` to manage user authentication state.
*   **`AppBAr` Component:** This functional component renders the app bar.
*   **Conditional Rendering:**  The code uses a ternary operator (`user ? ... : ...`) to display different content based on whether a user is logged in. If a user is logged in, a logout button and a greeting with their name are shown. Otherwise, a generic user icon is displayed.
*   **Styling:** The component uses Tailwind CSS classes for styling (e.g., `bg-slate-900`, `flex`, `justify-between`, `items-center`, `text-white`).

This component handles navigation links and user authentication status, providing a consistent header across the application.

#### Footer Component

Similarly, the `Footer` component in `components/shared/footer.tsx` provides the footer section.

```typescript jsx
import React from 'react';

const Footer: React.FC = () => {
  return (
    <footer className="bg-black text-white py-12 border-t border-slate-600">
      <div className="container mx-auto px-6 flex flex-col lg:flex-row justify-between items-start">
        
        <div className="flex flex-col items-center lg:pl-36 w-full lg:w-auto"> 
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="h-20 w-20 text-purple-500">
            <path strokeLinecap="round" strokeLinejoin="round" d="M17.25 6.75 22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3-4.5 16.5" />
          </svg>
          <p className="mt-4 text-lg text-gray-400 text-center">&copy; 2025 CodeVibe. All rights reserved.</p>
        </div>

        <div className='flex flex-col items-center justify-center flex-1 pt-6 mx-0 lg:mx-12 mt-16 lg:mt-0 w-full lg:w-auto'>
          <div className='flex gap-2 justify-center text-xl'>
            <p className='text-2xl'>Made with</p> 
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="h-6 w-6 text-red-500">
              <path d="m11.645 20.91-.007-.003-.022-.012a15.247 15.247 0 0 1-.383-.218 25.18 25.18 0 0 1-4.244-3.17C4.688 15.36 2.25 12.174 2.25 8.25 2.25 5.322 4.714 3 7.688 3A5.5 5.5 0 0 1 12 5.052 5.5 5.5 0 0 1 16.313 3c2.973 0 5.437 2.322 5.437 5.25 0 3.925-2.438 7.111-4.739 9.256a25.175 25.175 0 0 1-4.244 3.17 15.247 15.247 0 0 1-.383.219l-.022.012-.007.004-.003.001a.752.752 0 0 1-.704 0l-.003-.001Z" />
            </svg>
            <p className='text-2xl'>by</p>
          </div>
          <div className='flex gap-2 justify-center mt-2'>
            <p className='text'>Ganne ka Juice Paglus</p>
          </div>
        </div>

        <div className="flex flex-wrap justify-center lg:justify-start space-x-0 lg:space-x-12 mt-8 lg:mt-0 w-full lg:w-auto lg:pr-52">
          <div className="text-center p-4 lg:text-left mb-8 lg:mb-0">
            <h3 className="text-xl font-semibold mb-3 flex justify-center">Socials</h3>
            <div className='flex gap-4'>
              <ul className="space-y-2 text-gray-400 text-lg">
                <li><a className="hover:text-red-200">Twitter</a></li>
                <li><a className="hover:text-red-200">Discord</a></li>
              </ul>
              <ul className="space-y-2 text-gray-400 text-lg">
                <li><a className="hover:text-red-200">Instagram</a></li>
                <li><a className="hover:text-red-200">LinkedIn</a></li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </footer>
  );
};

export default Footer;
```

*   **Basic Structure:** It's a functional component returning a `footer` element.
*   **Content:** It includes a copyright notice, a "Made with ‚ù§Ô∏è by" section, and links to social media.
*   **Styling:**  Tailwind CSS classes are used for styling, providing a dark background, white text, and consistent spacing.

This ensures that every page has a consistent footer, providing important information to the user.

#### Button Component

The `Button` component in `components/ui/button.tsx` is a more complex example. It uses `class-variance-authority` (cva) to define different styles based on props.

```typescript jsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-[color,box-shadow] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40",
        outline:
          "border border-input bg-background shadow-xs hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
```

*   **`cva` Function:**  This function from `class-variance-authority` allows us to define different styles based on the `variant` and `size` props. This makes the button component highly customizable.
*   **Variants:** The `variant` prop allows us to create buttons with different styles (e.g., `default`, `destructive`, `outline`, `secondary`, `ghost`, `link`).
*   **Sizes:** The `size` prop allows us to create buttons of different sizes (e.g., `default`, `sm`, `lg`, `icon`).
*   **`cn` Function:** This utility function, likely from `@/lib/utils`, is used to conditionally apply class names.
*   **`asChild` Prop:**  This prop allows the `Button` component to render its children as a different HTML element using the `Slot` component from `@radix-ui/react-slot`.

This provides a flexible and reusable button component with various styles and sizes.

#### Input Component

The `Input` component in `components/ui/input.tsx` creates a styled input field.

```typescript jsx
import * as React from "react"
import { cn } from "@/lib/utils"

type InputProps = React.ComponentProps<"input"> & {
  fieldName?: "examples" | "testcases"
}

function Input({ className, type, fieldName, ...props }: InputProps) {
  const isNumber = type === "number"
  const isExamples = fieldName === "examples"
  const isTestcases = fieldName === "testcases"

  const constraints =
    isNumber && isExamples
      ? { min: 1, max: 5, defaultValue: 1 }
      : isNumber && isTestcases
      ? { min: 1, max: 10, defaultValue: 1 }
      : {}

  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...constraints}
      {...props}
    />
  )
}

export { Input }
```

*   **`InputProps` Type:** Defines the props for the component, including an optional `fieldName` for specific use cases.
*   **Conditional Constraints:** The code conditionally applies `min`, `max`, and `defaultValue` attributes to the input based on the `type` and `fieldName` props. This is useful for number inputs where you want to limit the range of values.
*   **Styling:** Uses Tailwind CSS classes for styling, including focus styles and disabled states.

This provides a styled and customizable input component that can be used throughout the application.

### Practical Example

Let's say you want to use the `Button` component in your "Contest" page.  You can import it and use it like this:

```typescript jsx
import { Button } from '@/components/ui/button';

const ContestPage = () => {
  return (
    <div>
      <h1>Contests</h1>
      <Button variant="secondary" size="lg">View All Contests</Button>
      <Button variant="outline">Create a Contest</Button>
    </div>
  );
};

export default ContestPage;
```

This will render two buttons with different styles and sizes, all using the same `Button` component.  This demonstrates the reusability and flexibility of the component.

### Summary

In this chapter, we learned about the importance of reusable UI components and how they contribute to a consistent and maintainable application. We explored the `AppBar`, `Footer`, `Button`, and `Input` components as examples of shared UI elements.  By using these components, we can avoid code duplication and ensure a uniform user experience throughout our application.

### Next Steps

In the next chapter, we'll delve deeper into state management and data fetching.
```

---

<a name="chapter-5-implementing-centralized-state-management-with-zustand"></a>

---

```markdown
## Chapter 5: Implementing Centralized State Management with Zustand

**Objective:** Manage application state using Zustand to share data and trigger updates efficiently across components.

In this chapter, we'll explore how to use Zustand, a small, fast, and scalable bearbones state-management solution, to manage your application's state in a centralized manner. Centralized state management becomes crucial as your application grows in complexity, allowing you to share data and trigger updates across different components without the complexities of prop drilling or context providers.

### Centralized State Management with Zustand

Zustand offers a simple and intuitive API for creating and managing state. It's particularly well-suited for React applications because it leverages React's hooks API.  Here's why you might choose Zustand:

*   **Simplicity:** Minimal boilerplate code compared to other state management libraries.
*   **Performance:** Optimized for performance and avoids unnecessary re-renders.
*   **Scalability:** Can handle complex application states with ease.
*   **Flexibility:** Unopinionated and integrates smoothly with React's component model.

The core concept of Zustand is the `create` function. This function takes a function as an argument, which defines your store. Inside this function, you define the state variables and the functions that update them. Zustand then returns a custom hook that allows you to access and modify the state from your components.

### Code Walkthrough

Let's examine the provided code snippets to understand how Zustand is implemented in our application.

**1. `store/codeEditorStore.js`:**

```javascript
import { create } from 'zustand';

const useCodeEditorStore = create((set) => ({
  runCount: 0,
  setRunCount: (count) => set({ runCount: count }),
  useLanguage: "javascript",
  setUseLanguage: (language) => set({ useLanguage: language }),
  userCode: "",
  setUserCode: (code) => set({ userCode: code }),
  adminKey: "",
  setadminKey: (key) => set({ adminKey: key }),
  adminExplaination: "",
  setAdminExplaination: (explanation) => set({ adminExplaination: explanation }),
}));

export default useCodeEditorStore;
```

This code defines a Zustand store called `useCodeEditorStore`.  Let's break it down:

*   `import { create } from 'zustand';`: Imports the `create` function from the `zustand` library.
*   `const useCodeEditorStore = create((set) => ({ ... }));`: Creates the store using the `create` function. The function passed to `create` receives a `set` function, which is used to update the state.
*   `runCount: 0,`: Defines a state variable `runCount` with an initial value of `0`. This could represent the number of times the code editor has been run.
*   `setRunCount: (count) => set({ runCount: count }),`: Defines a function `setRunCount` that updates the `runCount` state variable.  The `set` function merges the provided object with the existing state.
*   `useLanguage: "javascript",`: Defines the language used in the code editor, defaulting to javascript.
*   `setUseLanguage: (language) => set({ useLanguage: language }),`: Defines the `setUseLanguage` function to update the `useLanguage` state.
*   `userCode: "",`: Holds the code the user writes in the editor.
*   `setUserCode: (code) => set({ userCode: code }),`: Updates the `userCode` state.
*   `adminKey: "",`: Stores an admin key (likely used for special actions).
*   `setadminKey: (key) => set({ adminKey: key }),`: Updates the `adminKey` state.
*   `adminExplaination: "",`: Stores an explanation provided by an admin.
*   `setAdminExplaination: (explanation) => set({ adminExplaination: explanation }),`: Updates the `adminExplaination` state.
*   `export default useCodeEditorStore;`: Exports the custom hook `useCodeEditorStore`, which allows components to access and modify the state.

**2. `store/userStore.js`:**

```javascript
// userStore.js
import { create } from 'zustand';

const useUserStore = create((set) => ({
  user: null,
  token: null,

  // Initialize from localStorage
  initialize: () => {
    if (typeof window !== 'undefined') {
      const storedUser = localStorage.getItem('codevibe-user');
      const storedToken = localStorage.getItem('codevibe-token');
      set({ 
        user: storedUser ? JSON.parse(storedUser) : null,
        token: storedToken || null
      });
    }
  },

  // Set both user and token
  setAuth: (user, token) => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('codevibe-user', JSON.stringify(user));
      localStorage.setItem('codevibe-token', token);
    }
    set({ user, token });
  },

  // Update just user data
  setUser: (user) => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('codevibe-user', JSON.stringify(user));
    }
    set({ user });
  },

  // Clear auth data
  logout: () => {
    if (typeof window !== 'undefined') {
      localStorage.removeItem('codevibe-user');
      localStorage.removeItem('codevibe-token');
    }
    set({ user: null, token: null });
  },

  // Add contest to user's contests
  addContest: (contest) => {
    set((state) => {
      if (!state.user) return state;
      
      const updatedUser = {
        ...state.user,
        contests: [...(state.user.contests || []), contest]
      };

      if (typeof window !== 'undefined') {
        localStorage.setItem('codevibe-user', JSON.stringify(updatedUser));
      }

      return { user: updatedUser };
    });
  }
}));

export default useUserStore;
```

This store manages user authentication and data. Let's break down the key parts:

*   `user: null, token: null,`:  Initial state for the user object and authentication token.
*   `initialize: () => { ... }`: This function is called to initialize the user and token from `localStorage` when the application loads. This ensures that the user remains logged in even after refreshing the page. It checks `typeof window !== 'undefined'` to ensure it only runs in a browser environment.
*   `setAuth: (user, token) => { ... }`: Sets the user and token in both the store and `localStorage`. This is typically called after a successful login.
*   `setUser: (user) => { ... }`: Updates the user data in the store and `localStorage`.
*   `logout: () => { ... }`: Clears the user and token from the store and `localStorage`. This is called when the user logs out.
*   `addContest: (contest) => { ... }`: Adds a contest to the user's list of contests.  It uses the `set` function with a callback that receives the current state. This is useful for updating state based on its previous value.  It also persists the updated user object in `localStorage`.

### Practical Example

Let's say you have a component that displays the number of times the code editor has been run.  Here's how you would use the `useCodeEditorStore` to access and update the `runCount`:

```javascript
import React from 'react';
import useCodeEditorStore from '../store/codeEditorStore';

function RunCounter() {
  const runCount = useCodeEditorStore((state) => state.runCount);
  const setRunCount = useCodeEditorStore((state) => state.setRunCount);

  const handleRunClick = () => {
    setRunCount(runCount + 1);
  };

  return (
    <div>
      <p>Code Run Count: {runCount}</p>
      <button onClick={handleRunClick}>Run Code</button>
    </div>
  );
}

export default RunCounter;
```

In this example:

1.  We import the `useCodeEditorStore` hook.
2.  We use the hook to select the `runCount` and `setRunCount` from the store.
3.  We display the `runCount` in the component.
4.  We create a button that, when clicked, calls the `setRunCount` function to increment the `runCount`.

This is a simplified example, but it demonstrates the basic principles of using Zustand to manage state in your components. The component automatically re-renders whenever the `runCount` changes in the store.

### Summary

In this chapter, you learned how to implement centralized state management using Zustand. You saw how to create stores, define state variables, and create functions to update the state. You also learned how to access and modify the state from your components using the custom hooks generated by Zustand. Zustand's simplicity and performance make it an excellent choice for managing application state in React.

### Next Steps

In the next chapter, we'll explore how to use React Context in conjunction with Zustand to further optimize state management and improve component reusability.
```

---

<a name="chapter-6-creating-a-dynamic-code-editor-feature"></a>

---

## Chapter 6: Creating a Dynamic Code Editor Feature

**Introduction:**

In this chapter, we'll embark on a journey to build a dynamic code editor feature for our application. This feature will allow users to access a fully functional code editor through a dynamic route, enabling real-time code editing and interaction. We'll leverage state management to maintain the editor's content and UI components to create a seamless user experience. By the end of this chapter, you'll have a solid understanding of how to integrate a code editor into your application and manage its state effectively.

**Explanation: Code Editor Feature**

A code editor feature empowers users to write, edit, and execute code directly within your application. This enhances interactivity and provides a more engaging experience. Key components of this feature include:

*   **Code Editor Component:** This UI element handles the display and editing of code. Popular libraries like Monaco Editor or CodeMirror can be used for this.
*   **Dynamic Routing:** A dynamic route allows users to access specific code editor instances based on unique identifiers (e.g., `/editor/123`).
*   **State Management:**  A system to store and update the code editor's content. This ensures that changes are persisted and reflected in the UI. We'll use a simple state management approach in this chapter.
*   **Language Support:** The editor should support different programming languages with syntax highlighting and autocompletion for a better user experience.

**Code Walkthrough:**

Since no specific code snippets were provided, I will create a hypothetical scenario using React and the Monaco Editor to demonstrate the concepts.

Let's assume we have the following component structure:

*   `src/pages/Editor/[id].js`: This file handles the dynamic route for the code editor.
*   `src/components/CodeEditor.js`: This file contains the Monaco Editor component and its associated logic.

**`src/pages/Editor/[id].js`**

```javascript
// src/pages/Editor/[id].js
import { useRouter } from 'next/router';
import CodeEditor from '../../components/CodeEditor';
import { useState, useEffect } from 'react';

function EditorPage() {
  const router = useRouter();
  const { id } = router.query;
  const [initialCode, setInitialCode] = useState('');

  // Simulate fetching initial code based on the ID
  useEffect(() => {
    if (id) {
      // In a real application, you would fetch this from an API
      const codeMap = {
        '1': '// Example code for ID 1\nconsole.log("Hello from Editor 1!");',
        '2': '// Example code for ID 2\nfunction add(a, b) {\n  return a + b;\n}',
      };
      setInitialCode(codeMap[id] || '// No code found for this ID');
    }
  }, [id]);

  return (
    <div>
      <h1>Code Editor - ID: {id}</h1>
      <CodeEditor initialValue={initialCode} />
    </div>
  );
}

export default EditorPage;
```

**Explanation:**

*   This component uses `next/router` to access the dynamic route parameter `id`.
*   It uses `useState` to manage the initial code for the editor.
*   The `useEffect` hook simulates fetching initial code based on the `id`.  In a real-world application, you'd replace this with an API call.
*   It passes the `initialCode` to the `CodeEditor` component.

**`src/components/CodeEditor.js`**

```javascript
// src/components/CodeEditor.js
import React, { useState, useRef, useEffect } from 'react';
import MonacoEditor from 'react-monaco-editor'; // Assuming you have this installed

function CodeEditor({ initialValue }) {
  const [code, setCode] = useState(initialValue);
  const editorRef = useRef(null);

  const handleEditorDidMount = (editor, monaco) => {
    editorRef.current = editor;
  };

  const handleEditorChange = (value) => {
    setCode(value);
  };

  useEffect(() => {
    setCode(initialValue); // Update code when initialValue changes
  }, [initialValue]);

  return (
    <MonacoEditor
      width="800"
      height="600"
      language="javascript"
      theme="vs-dark"
      value={code}
      onChange={handleEditorChange}
      editorDidMount={handleEditorDidMount}
    />
  );
}

export default CodeEditor;
```

**Explanation:**

*   This component uses the `react-monaco-editor` library (you'll need to install it: `npm install react-monaco-editor`).
*   `useState` manages the current code in the editor.
*   `useRef` provides a way to access the Monaco Editor instance directly.
*   `handleEditorDidMount` is called when the editor is mounted and stores a reference to the editor instance.
*   `handleEditorChange` is called whenever the code in the editor changes and updates the `code` state.
*   The `useEffect` hook ensures that the editor's content is updated when the `initialValue` prop changes.

**Practical Example:**

1.  Install `react-monaco-editor`: `npm install react-monaco-editor`
2.  Create the files `src/pages/Editor/[id].js` and `src/components/CodeEditor.js` with the code provided above.
3.  Run your development server (e.g., `npm run dev`).
4.  Navigate to `http://localhost:3000/editor/1` or `http://localhost:3000/editor/2` in your browser. You should see a code editor with the corresponding initial code loaded.  You can edit the code and the editor will update in real-time.  Try navigating to `/editor/3`. Since we don't have initial code defined for ID 3, the editor will load with the default message.

**Summary:**

In this chapter, we successfully created a dynamic code editor feature. We explored how to use dynamic routes to access specific editor instances, and we used state management to maintain the editor's content. We also integrated a UI component (Monaco Editor) to provide a rich editing experience.  You learned how to pass initial values to the editor and handle changes to the code.

**Next Steps:**

In the next chapter, we will explore how to add more advanced features to our code editor, such as saving code to a database and implementing real-time collaboration.

---

<a name="chapter-7-building-a-discussion-feature"></a>

---

```markdown
## Chapter 7: Building a Discussion Feature

**Objective:** Implement a discussion feature with dedicated pages and reusable discussion cards.

**Introduction:**

In this chapter, we'll be diving into the exciting world of interactive features by building a discussion component. This feature will allow users to engage with content, share their thoughts, and learn from each other. We will create reusable discussion cards and integrate them into a dedicated page. This practical walkthrough will help you understand how to implement real-time commenting functionality in your applications.

**Understanding the Discussion Feature**

A discussion feature is a crucial element for fostering community and engagement on any platform.  It allows users to share their thoughts, ask questions, and receive feedback. A well-designed discussion feature should be:

*   **Easy to Use:**  The interface should be intuitive and straightforward.
*   **Interactive:** Users should be able to easily post, read, and reply to comments.
*   **Real-time (or Near Real-time):** Updates should be reflected quickly to encourage active participation.
*   **Maintainable:** The codebase should be organized and scalable.

In our example, we'll be focusing on building a reusable `DiscussionCard` component that fetches and displays comments, and allows logged-in users to add new comments.

**Code Walkthrough: `DiscussionCard` Component**

Let's examine the code for the `DiscussionCard` component located in `components/shared/discussion-card.tsx`.

```typescript
import React, { useEffect, useState } from 'react';
import { Button } from "@/components/ui/button";
import { Textarea } from '@/components/ui/textarea';
import { BASE_URL } from '@/lib/url';
import useUserStore from '@/store/userStore';

interface Comment {
  _id: string;
  name: string;
  text: string;
  createdAt: string;
}

const DiscussionCard = ({ _id, name, title, desc, date }: {
  _id: string;
  name: string;
  title: string;
  desc: string;
  date: string;
}) => {
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState('');
  const [showComments, setShowComments] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const { user } = useUserStore();

  const fetchComments = async () => {
    setIsLoading(true);
    setError(null);
    try {
      console.log(`Fetching comments for post ${_id}`);
      const response = await fetch(`${BASE_URL}/api/v1/discussion/${_id}/comments`, {
        headers: {
          'ngrok-skip-browser-warning': 'true'
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.message || 'Failed to fetch comments');
      }
  
      const data = await response.json();
      console.log('Received comments:', data);
      setComments(Array.isArray(data) ? data : []);
    } catch (error) {
      console.error('Error fetching comments:', error);
      setError(error instanceof Error ? error.message : 'Failed to fetch comments');
      setComments([]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleAddComment = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!user) {
      setError('You must be logged in to comment');
      return;
    }

    if (!newComment.trim()) {
      setError('Comment cannot be empty');
      return;
    }

    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch(`${BASE_URL}/api/v1/discussion/${_id}/comments`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
          'ngrok-skip-browser-warning': 'true'
        },
        body: JSON.stringify({ 
          name: user.name,
          text: newComment,
          postTitle : title,
          userId: user._id // Include user ID
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to add comment');
      }

      const addedComment = await response.json();
      setComments(prev => [addedComment, ...prev]);
      setNewComment('');
    } catch (error) {
      console.error('Error adding comment:', error);
      setError(error instanceof Error ? error.message : 'Failed to add comment');
    } finally {
      setIsLoading(false);
    }
  };

  const toggleComments = () => {
    if (!showComments) {
      fetchComments();
    }
    setShowComments(!showComments);
  };

  return (
    <div className='bg-slate-800 p-4 rounded-lg shadow-md flex space-x-4 mb-4'>
      <div>
        <p className='bg-purple-500 p-4 rounded-full'>
          {name[0].toUpperCase() + (name[1] ? name[1].toUpperCase() : '')}
        </p>
      </div>
      <div className="flex-1">
        <div className='space-y-2'>
          <p className='font-bold'>{name}</p>
          <p className='text-xl font-bold'>{title}</p>
          <p className=''>{desc}</p>
          <p className='text-sm text-gray-400'>
            {new Date(date).toLocaleString()}
          </p>
          
          <Button 
            onClick={toggleComments}
            variant="outline"
            className="mt-2 text-sm bg-gray-700 hover:bg-gray-600"
            disabled={isLoading}
          >
            {isLoading ? 'Loading...' : `${showComments ? 'Hide' : 'View'} Comments`}
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="h-6 w-6">
              <path strokeLinecap="round" strokeLinejoin="round" d="M20.25 8.511c.884.284 1.5 1.128 1.5 2.097v4.286c0 1.136-.847 2.1-1.98 2.193-.34.027-.68.052-1.02.072v3.091l-3-3c-1.354 0-2.694-.055-4.02-.163a2.115 2.115 0 0 1-.825-.242m9.345-8.334a2.126 2.126 0 0 0-.476-.095 48.64 48.64 0 0 0-8.048 0c-1.131.094-1.976 1.057-1.976 2.192v4.286c0 .837.46 1.58 1.155 1.951m9.345-8.334V6.637c0-1.621-1.152-3.026-2.76-3.235A48.455 48.455 0 0 0 11.25 3c-2.115 0-4.198.137-6.24.402-1.608.209-2.76 1.614-2.76 3.235v6.226c0 1.621 1.152 3.026 2.76 3.235.577.075 1.157.14 1.74.194V21l4.155-4.155" />
            </svg> 
          </Button>

          {error && (
            <div className="text-red-500 mt-2 text-sm">{error}</div>
          )}

          {showComments && (
            <div className="mt-4 border-t border-gray-700 pt-4">
              <div className="space-y-3 mb-4">
                {isLoading && comments.length === 0 ? (
                  <div>Loading comments...</div>
                ) : comments.length === 0 ? (
                  <div className="text-gray-400">No comments yet</div>
                ) : (
                  comments.map((comment) => (
                    <div key={comment._id} className="bg-gray-700 p-3 rounded-lg">
                      <div className="font-semibold">{comment.name}</div>
                      <p className="text-gray-300">{comment.text}</p>
                      <div className="text-xs text-gray-400 mt-1">
                        {new Date(comment.createdAt).toLocaleString()}
                      </div>
                    </div>
                  ))
                )}
              </div>

              {user ? (
                <form onSubmit={handleAddComment} className="space-y-2">
                  <div className="text-sm text-gray-300">
                    Commenting as: <span className="font-semibold">{user.name}</span>
                  </div>
                  <Textarea
                    placeholder="Write a comment..."
                    value={newComment}
                    onChange={(e) => setNewComment(e.target.value)}
                    required
                    disabled={isLoading}
                    className="bg-gray-700 border-gray-600"
                  />
                  <Button
                    type="submit"
                    disabled={isLoading || !newComment.trim()}
                    className="bg-purple-600 hover:bg-purple-500"
                  >
                    {isLoading ? 'Posting...' : 'Add Comment'}
                  </Button>
                </form>
              ) : (
                <div className="text-gray-400 text-sm">
                  Please log in to leave a comment
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default DiscussionCard;
```

Let's break down the code:

*   **Imports:** The code imports necessary React hooks (`useState`, `useEffect`), UI components (`Button`, `Textarea`), the base URL for API calls (`BASE_URL`), and a custom hook for managing user data (`useUserStore`).
*   **`Comment` Interface:** Defines the structure of a comment object, including its ID, author's name, text, and creation date.
*   **`DiscussionCard` Component:** This is the main component that displays a discussion post and its comments. It receives props for the post's ID, author's name, title, description, and date.
*   **State Variables:**
    *   `comments`: Stores an array of comments fetched from the API.
    *   `newComment`: Stores the text of the comment being written by the user.
    *   `showComments`: A boolean flag to control the visibility of the comments section.
    *   `isLoading`: A boolean flag to indicate whether data is being fetched or a comment is being posted.
    *   `error`: Stores any error message that occurs during API calls.
*   **`useUserStore` Hook:** Retrieves the current user's information from a global state. This is used to display the commenter's name and associate the comment with the user.
*   **`fetchComments` Function:**
    *   Fetches comments from the API endpoint `BASE_URL/api/v1/discussion/${_id}/comments`.
    *   Handles loading and error states.
    *   Updates the `comments` state with the fetched data.
*   **`handleAddComment` Function:**
    *   Handles the submission of a new comment.
    *   Validates that the user is logged in and that the comment is not empty.
    *   Posts the new comment to the API endpoint.
    *   Updates the `comments` state with the newly added comment.  The `Authorization` header includes the user's token for authentication. The body includes the `userId` to associate the comment with the user in the database.
*   **`toggleComments` Function:** Toggles the visibility of the comments section and fetches comments if they are not already loaded.
*   **JSX Structure:**
    *   Displays the post's author, title, description, and date.
    *   A "View Comments" button that toggles the visibility of the comments section.
    *   A list of comments, fetched from the API.
    *   A form for adding new comments (only visible to logged-in users).

**Practical Example**

Imagine you're building a forum for a coding bootcamp.  You can use the `DiscussionCard` component to display each topic.  On a specific topic page, you would map through an array of discussion objects and render a `DiscussionCard` for each one.

```jsx
// Example Usage (Simplified)
import DiscussionCard from './components/shared/discussion-card';

const TopicPage = ({ discussions }) => {
  return (
    <div>
      {discussions.map((discussion) => (
        <DiscussionCard
          key={discussion._id}
          _id={discussion._id}
          name={discussion.name}
          title={discussion.title}
          desc={discussion.desc}
          date={discussion.date}
        />
      ))}
    </div>
  );
};

export default TopicPage;

// Example discussions array (replace with your actual data)
const discussions = [
  {
    _id: "1",
    name: "Alice",
    title: "Understanding React Hooks",
    desc: "Can someone explain the useReducer hook?",
    date: "2024-01-01T12:00:00.000Z",
  },
  {
    _id: "2",
    name: "Bob",
    title: "Best Practices for API Design",
    desc: "What are some good patterns for designing RESTful APIs?",
    date: "2024-01-02T10:00:00.000Z",
  },
];
```

In this example, `TopicPage` receives an array of `discussions` and renders a `DiscussionCard` for each discussion item. Each card will then handle fetching its specific comments and allowing users to add their own.

**Summary**

In this chapter, we've successfully implemented a reusable `DiscussionCard` component, which fetches and displays comments, and allows logged-in users to add new comments.  We covered fetching data from an API, handling user input, displaying loading and error states, and integrating with a user authentication system. This component can be easily integrated into any page where you want to enable discussions.

**Next Steps**

In the next chapter, we will explore how to implement real-time updates using WebSockets, allowing for a more interactive and engaging discussion experience. This will involve setting up a WebSocket server and client to push new comments to all connected users in real-time.
```
